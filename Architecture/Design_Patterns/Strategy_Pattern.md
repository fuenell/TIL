# Strategy Pattern
알고리즘군을 정의하고 각각 캡슐화하여 교환해서 사용할 수 있도록 만든다  
스트래티지 패턴을 활용하면 알고리즘을 사용하는 클라이언트와는 독립적으로 알고리즘을 변경할 수 있다

## 문제
오리 시뮬레이션 프로그램에서 행동이 다른 오리가 추가되는 상황  
현재 상태는 Duck 이라는 추상 클래스는 만들어 상속받는다


### 1단계 (함수 오버라이드)
행동이 다른 오리가 상속받는 행동을 오버라이드한다
![1](https://user-images.githubusercontent.com/37904040/104694744-f9815380-574e-11eb-8d9a-24b810f87761.PNG)  

#### 단점
- 행동이 다른 오리가 추가될 때 마다 함수를 오버라이드 해줘야한다  
`오버라이드 지옥에 빠진다`
  
- 서브클래스에서 코드가 중복된다  
`함수를 일괄적으로 변경할 수 없다`
  
- 모든 오리의 행동을 알기 힘들다  
`날지 못하는 오리의 Fly()함수를 수정하려면 오버라이드가 된 함수를 모두 찾아보며 수정해야 한다`

---

### 2단계 (행동 인터페이스로 분리)
행동을 인터페이스로 분리해서 필요한 종들만 구현한다
![2](https://user-images.githubusercontent.com/37904040/104697159-af01d600-5752-11eb-8b61-8625da619e55.PNG)
#### 단점
- 여전히 1단계의 단점을 그대로 가지고 있다

---

### 3단계 (인터페이스를 구성으로)
행동을 다른 클래스로 위임해 각자의 클래스에서 구현한다  
이후 행동을 인터페이스를 상속이 아닌 구성으로 Duck 클래스에 포함시킨다
![3](https://user-images.githubusercontent.com/37904040/104697162-b0330300-5752-11eb-8c4f-d1eb2bae25b3.PNG)

#### 장점
- 행동을 동적으로 지정할 수 있다  
`Setter를 이용해 quackBehavior의 값을 Quack에서 Squeak로 변경`
- 새로운 행동을 가진 오리 추가 시 기존 코드를 수정할 필요가 없다  
`새로운 행동을 인터페이스를 구현해서 제작 후 새로운 오리의 생성자에 넣으면 끝`
