# 암시적 형변환 (Implicit Conversion)
C++에서 함수의 전달인자는 다음 4단계를 통해 자신에게 맞는 함수를 찾아간다

---
#### 1. 자신과 타입이 정확히 일치하는 함수를 찾는다

#### 2. 정확히 일치하는 타입이 없는 경우 아래와 같은 형변환을 통해서 일치하는 함수를 찾아본다  
`Char, unsigned char, short 는 int 로 변환된다`  
`Unsigned short 는 int 의 크기에 따라 int 혹은 unsigned int 로 변환된다`  
`Float 은 double 로 변환된다`  
`Enum 은 int 로 변환된다`  

#### 3. 위와 같이 변환해도 일치하는 것이 없다면 아래의 좀더 포괄적인 형변환을 통해 일치하는 함수를 찾는다  
`임의의 숫자(numeric) 타입은 다른 숫자 타입으로 변환된다. (예를 들어 float -> int)`  
`Enum 도 임의의 숫자 타입으로 변환된다 (예를 들어 Enum -> double)`  
`0 은 포인터 타입이나 숫자 타입으로 변환된 0 은 포인터 타입이나 숫자 타입으로 변환된다`  
`포인터는 void 포인터로 변환된다`

#### 4. 유저 정의된 타입 변환으로 일치하는 것을 찾는다  
`매개변수의 생성자를 통해 자동으로 객체를 생성한다`

---

만약에 컴파일러가 위 과정을 통하더라도 일치하는 함수를 찾을 수 없거나,  
같은 단계에서 두 개 이상이 일치하는 경우에 모호하다 (ambiguous) 라고 판단해서 오류를 발생하게 됩니다

## 클래스 암시적 형변환
아래의 예제에서는 4단계가 작동하며 3이 A클래스의 생성자를 통해 형변환이 발생한다
``` C++
class A {
public:
  A(int a) {
    cout << "A 생성자 작동";
  }
};

void test_implicit(A a) {
  //...
}

int main() {
  test_implicit(3);   // 암시적 형변환  test_implicit(A(3)) 와 똑같이 작동한다
  
  A a = 3;            // 암시적 형변환  A a(3) 와 똑같이 작동한다
}
```

## 명시적 키워드 Explicit
하지만 이런 기능이 항상 편리한 것은 아니다  
예상하지 못한 상황에서 암시적 형변환이 일어나서 원하지 않는 결과를 얻을 수 있다  
이런 상황을 예방하기 위해 생성자에 `explicit` 키워드를 추가해 암시적 형변환을 막을 수 있다
``` C++
class A {
public:
  explicit A(int a) {
    cout << "명시적 생성자";
  }
};
```
