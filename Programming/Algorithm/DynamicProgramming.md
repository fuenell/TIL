# 동적 프로그래밍 (Dynamic Programming)
문제의 크기가 작은 소문제에 대한 해를 테이블 저장해 놓고 이를 이용하여 크기가 보다 큰 문제의 해를 점진적으로 만들어가는 상향식 접근 방법

## 피보나치 수열

피보나치 수열은 `0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233` 

와 같이 `n`번째 오는 숫자가 `n-1` 과 `n-2`번째 수의 합이되는 수열이다 (단 0번은 0, 1번은 1)

피보나치 수열은 대표적으로 동적 프로그래밍 방법으로 해결하기 좋은 문제 중 하나다

피보나치 수열의 점화식과 코드는 다음과 같다

`F(n) = F(n-1) + F(n-2)`

``` C#
int Fibo(int n)
{
	if(n < 2)
		return n;

	int[] arr = new int[n + 1];
	arr[0] = 0;
	arr[1] = 1;
	
	for(int i = 2; i <= n; i++)
		arr[i] = arr[i - 1] + arr[i - 2];
		
	return arr[n];
}
```

만약 피보나치 수열을 분할 정복 방법인 순환 구조로 구하게 된다면 고작 50번째 수열을 구하는 시간 조차 엄청 오래 걸릴 것이다

## 연쇄 행렬 곱셈 문제

행렬을 연속적으로 곱할 때 최소의 곱셈 연산수를 가지는 연산 순서를 구하는 문제

다음과 같은 점화식으로 풀 수 있다

```
C(i,j) = MIN[	for(i <= k <= j-1){
					C(i,k) ~ C(k+1,j)
				}
				+(di-1) * dk * dj
			]
```



``

```C#
int MinMatrixMul(int n, int[] d)	// n: 행렬의 수, d: 차원수가 담긴 배열
{
	int k;
	int[,] C = new int[n+1, n+1];	// C(i,j)계산 시 곱셈 횟수의 최솟값
	
   	for(int i=1; i<=n; i++)			// 자신과 곱셈 횟수는 0
   		C[i][i] = 0;
   		
   	for(int s=1; s<=n-1; s++)	// s: 곱하는 행렬의 수
   	{
   		for(int i=1; i<=n-s; i++)
   		{
   			j = i+s;	// (i, i+s)
   			C[i][j] = Min(d, i, j, out int k);	// C(i,j)의 최솟값을 구한다
   			P[i][j] = k;	// k: 최솟값이 나온 분할 지점
   		}
   	}
    
   	return C[1][n];
}
```

## 스트링 편집 거리 문제

문자열 `X`를 다른 문자열 `Y`로 변환하는 필요한 편집 연산의 최소 비용을 편집 거리라고 한다

편집거리는 두 문자열 사이의 근접성 또는 유사성을 판단하는 척도가 된다

편집 연산은 다음과 같은 종류가 있다 (각 연산은 각자의 비용이 있지만 여기에서는 1, 1, 2로 둔다)

- 삽입 (Ｉ 비용 1)
- 삭제 (Ｄ 비용 1)
- 변경 (Ｃ 비용 2)

예를 들어 `SUM` 이라는 문자열을 `SUN`으로 변환하려면, `M`을 `N`으로 변경하거나, `M`을 삭제하고 `N`을 삽입하면 된다 둘 다 비용이 2 필요하므로 편집 거리는 2라고 볼 수 있다

다음과 같은 점화식을 세워 문제를 풀 수 있다

`E(i, j)` 는 길이가 `i`인 문자열 `X`에서 길이가 `j`인 문자열 `Y`까지의 편집 거리다

```
E(i, j) = min[E(i - 1, j) + Ｄ,
			  E(i, j - 1) + Ｉ,
			  E(i - 1, j - 1) + Ｃ]
```

## 모든 정점 최단 경로 문제 (플로이드 알고리즘)

가중치 방향 그래프에서 두 정점을 연결하는 최단경로를 한번에 모두 구하는 문제

(단 가중치가 감소하는 루프는 없어야 한다)

`D(k, i, j)`는 정점 `k`를 경유해  `i`에서 `j`로 가는 최단 거리다

`k`에 정점의 개수를 넣으면 모든 최단경로를 구할 수 있다

```
D(k,i,j) = min[D(k-1, i, j),
			   D(k-1, i, k) + D(k-1, k, j)]
```

## 저울 문제

무게 M인 물체를 n개의 추로 같은 무게를 맞출 수 있는지 확인하는 문제

(단 물체와 추의 무게는 정수여야 한다)

다음과 같은 점화식을 유도해 풀 수 있다

`S(i, k)`는 무게가 ` k`인 물체를 `i`개의 추를 사용해 무게를 맞출 수 있으면 1 아니면 0을 반환

```
S(i, K) = max[S(i-1, k),		// 마지막 추를 사용하지 않는 경우
			  S(i-1, k-Wi)]		// 마지막 추를 사용하는 경우
			  
S(i,0) = 1
S(i,음수) = 0
S(0,k) = 0		// 1 <= k
```



