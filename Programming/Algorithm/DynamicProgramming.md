# 동적 프로그래밍 (Dynamic Programming)
문제의 크기가 작은 소문제에 대한 해를 테이블 저장해 놓고 이를 이용하여 크기가 보다 큰 문제의 해를 점진적으로 만들어가는 상향식 접근 방법

## 피보나치 수열

피보나치 수열은 `0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233` 

와 같이 `n`번째 오는 숫자가 `n-1` 과 `n-2`번째 수의 합이되는 수열이다 (단 0번은 0, 1번은 1)

피보나치 수열은 대표적으로 동적 프로그래밍 방법으로 해결하기 좋은 문제 중 하나다

``` C#
int Fibo(int n)
{
	if(n < 2)
		return n;

	int[] arr = new int[n + 1];
	arr[0] = 0;
	arr[1] = 1;
	
	for(int i = 2; i <= n; i++)
		arr[i] = arr[i - 1] + arr[i - 2];
		
	return arr[n];
}
```

만약 피보나치 수열을 분할 정복 방법인 순환 구조로 구하게 된다면 고작 50번째 수열을 구하는 시간 조차 엄청 오래 걸릴 것이다

## 연쇄 행렬 곱셈 문제

행렬을 연속적으로 곱할 때 최소의 곱셈 연산수를 가지는 연산 순서를 구하는 문제

다음과 같은 점화식으로 풀 수 있다

`C(i,j) = MIN(i<=k<=j-1){C(i,k) ~ C(k+1,j)}+di-1*dk*dj`

```C#
int MinMatrixMul(int n, int[] d)	// n: 행렬의 수, d: 차원수가 담긴 배열
{
	int k;
	int[,] C = new int[n+1, n+1];	// C(i,j)계산 시 곱셈 횟수의 최솟값
	
   	for(int i=1; i<=n; i++)			// 자신과 곱셈 횟수는 0
   		C[i][i] = 0;
   		
   	for(int s=1; s<=n-1; s++)	// s: 곱하는 행렬의 수
   	{
   		for(int i=1; i<=n-s; i++)
   		{
   			j = i+s;	// (i, i+s)
   			C[i][j] = Min(d, i, j, out int k);	// C(i,j)의 최솟값을 구한다
   			P[i][j] = k;	// k: 최솟값이 나온 분할 지점
   		}
   	}
    
   	return C[1][n];
}
```

