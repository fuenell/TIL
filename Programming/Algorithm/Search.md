# 탐색 (Search)
## 순차탐색

**선형 자료구조** 형태로 주어진 원소들을 처음부터 하나씩 비교하면서 탐색하는 방법

삽입, 삭제: `O(1)`	// 특정 원소 삭제 시 `O(n)`

탐색: `O(n)`

## 이진탐색

**정렬된 배열** 형태로 주어진 원소를 절반씩 줄여가면서 탐색하는 방법

삽입, 삭제: `O(n)`	// 데이가 정렬된 상태를 유지해야 하기 때문에

탐색 (평균): `O(log n)`

## 이진 탐색 트리

이진 탐색을 트리 형태로 변환한 것

삽입, 삭제, 탐색 (평균): `O(log n)` / (최악): `O(n)`

### 흑적트리

이진 탐색 트리에 몇가지 규칙을 적용해 균형 탐색 트리로 만들어 확정적으로 `O(log n)`의 탐색시간을 가지는 방법

탐색, 삽입, 삭제: `O(log n)`

### B-트리

노드를 분할해 루트 노드의 부모노드를 만들며 삽입할 수록 위로 올라가도록 설계된 트리

때문에 모든 리프 노드의 레벨은 같다

탐색, 삽입, 삭제: `O(log n)`

## 해싱

해시 함수를 통해 키값으로 해시 테이블 속 값을 바로 찾는 방법

탐색 시간이 상수시간이라는 장점이 있지만 해시 함수 충돌을 조심해야 한다

탐색, 삽입, 삭제: `O(1)`

#### 해시 함수 종류

제산 잔여법: 키값을 해시 테이블 크기로 나눈 나머지를 해시값으로 하는 방법

비닝: 키값을 해시 테이블 크기로 나눈 몫을 해시값으로 하는 방법

중간 제곱법: 키값을 제곱해서 해시 테이블 크기의 자릿수를 해시값으로 하는 방법

#### 충돌 해결 방법

- 개방 해싱: 충돌된 테이블을 연결 리스트로 연결해서 추가하는 방법
- 버킷 해싱: 테이블 마다 n개의 크기를 가진 버킷을 만들어 충돌된 데이터를 밑에 저장하는 방법
- 선형 탐사: 충돌된 데이터를 바로 밑에 보관하는 방법 -> 1차 클러스터링 문제 발생
- 이차 탐사: 충돌된 데이터를 이차식을 더한 위치에 보관하는 방법 -> 2차 클러스터링 문제 발생
- 이중 해싱: 선형 또는 이차 탐사를 두번 적용하는 방법

